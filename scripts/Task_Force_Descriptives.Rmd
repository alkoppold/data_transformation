---
title: "Task_Force_Descriptives"
author: "Alina Koppold"
date: "2023-11-08"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(scales)
library(MASS)
library(DescTools)
library(moments)
library(patchwork)
library(tidyverse)
```

```{r helpers}
boxcoxvec = function(x, min=1) { #cf. scales::boxcox_trans()
  if (min %>% is.numeric()) x = x - min(x, na.rm=T) + min
  lambda = boxcox(x ~ 1, plotit=F) %>% 
    bind_cols() %>% filter(y == max(y)) %>% pull(x) %>% mean()
  return((x ^ lambda - 1) / lambda)
}

myGgTheme = theme(
  axis.title.x = element_text(size = 12, face = "bold"),
  axis.title.y = element_text(size = 12, face = "bold"),
  axis.text.y = element_text(size = 10, face = "bold"),
  axis.text.x = element_text(size = 10, face = "bold"),
  strip.background = element_blank(),
  panel.border = element_blank(),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  panel.background = element_blank(),
  axis.line.x = element_line(colour = 'black', size=0.5, linetype='solid'),
  axis.line.y = element_line(colour = 'black', size=0.5, linetype='solid'))

prune = function(x, low=-Inf, high=+Inf, abs=NA) {
  result = if_else(x < low, low, x) %>% if_else(. > high, high, .)
  if (abs %>% is.na() == F) result = if_else(abs(result) > abs, abs * if_else(result > 0, 1, -1), result)
  return(result)
}

#reliability
reliability_helper = function(data, fn_score, replications, #need to be specified
                              participants="id", stratification=NULL, #constant for one data set
                              fn_coef=splithalfr::spearman_brown, ncores=parallel::detectCores() - 1, careful=F, verbose=F) #sensible defaults
{
  if (stratification %>% is.null() == F) stratification = data %>% pull(!!stratification)
  splithalfr::by_split(data=data, fn_score=fn_score, replications=replications,
                       participants = data %>% pull(!!participants), 
                       stratification = stratification,
                       ncores=ncores, careful=careful, verbose=verbose) %>% 
    splithalfr::split_coefs(fn_coef=fn_coef)
}

fn_score_mean = function(column, na.rm=T) { #idea: create a function that
  return(function(df) { #returns another function 
    return(mean(dplyr::pull(df, !!column), na.rm=na.rm)) #with specifications (column & na.rm) from the parent-function => parameter df gets filled inside by_split function call
    #note: this would not be needed if by_split had a "..." argument that gets passed into fn_score
    
    #return(df %>% pull(!!column) %>% mean(na.rm=na.rm)) #requires library(tidyverse) for parallel (inefficient)
  })
}

rToFishZ = function(r) { return(.5*log((1+r)/(1-r))) }
fishZtoR = function(Z) { return(ifelse(Z==Inf, 1, (exp(2*Z)-1)/(exp(2*Z)+1))) }
fnFishZ = function(r, fn=mean, prune=.999, ...) { 
  warning.txt = ""
  if (any(abs(r) >= 1, na.rm=T)) {
    warning.txt = "Correlation(s) contain(s) values at or beyond 1. This will bias results for summary functions." %>% paste0(warning.txt, .)
    if (prune %>% is.na()) warning = "Consider setting prune parameter." %>% paste(warning.txt, .)
    else {
      warning.txt = paste0("Pruning to ", prune, ".") %>% paste(warning.txt, .)
      
      r = r %>% prune(abs=prune) #if_else(abs(r) >= 1, prune * if_else(r > 0, 1, -1), r)
    }
    warning(warning.txt)
  }
  
  return(r %>% rToFishZ() %>% fn(...) %>% fishZtoR()) 
}
```

```{r data}
# loading the original data 
#X7163CM_8163CM_EDA_ac <- read_sav("data/7163CM_8163CM_EDA_ac.sav")

#TODO for better reproducibility, should we add the code for reshaping the data here?
#good idea! 
  
  
# in long format 
load("./data/long_EDA_merz.Rdata") #variable: data_long

# Rename some variables, delete variable condition and delete cspu, ucsm and ucsw
# names(data_long)[grep("Versuchspersonennummer", names(data_long))] <- "id"
# names(data_long)[grep("scr", names(data_long))] <- "scr_raw"
# data_long <- data_long[ ,c("id","trialnr","stimulus","scr_raw")]
# data_long <- data_long[-grep("cspu|ucsm|ucsw", data_long$stimulus) , ]

data_long = data_long %>% rename(id = Versuchspersonennummer, scr_raw = scr) %>% 
  filter(stimulus %in% c("cspe", "csm", "ucs")) %>% #only keep responses to CS+ (will be extinguished), CS-, and UCS
  mutate(stimulus = if_else(stimulus == "cspe", "csp", stimulus), #rename cspe to csp for generalizability to other data sets
         stim_cat = if_else(stimulus %>% startsWith("cs"), "cs", "ucs")) %>% 
  select(id, trialnr, stimulus, stim_cat, scr_raw) #get rid of "condition" and reorder
```

```{r transformations}
# # Log-transform the raw data
# data_long$scr_log <- log10(1+data_long$scr_raw)
# 
# # Square root transform the raw data
# data_long$scr_sqr <- sqrt(data_long$scr_raw)
# 
# # Box cox transform the data: the added positive constant is the smallest raw SCR within the data set
# b <- boxcox(lm(data_long$scr_raw - min(data_long$scr_raw) + 1 ~ 1), plotit=F)
# # Extract lambda
# lambda <- b$x[which.max(b$y)]
# lambda
# data_long$scr_box <- (data_long$scr_raw ^ lambda - 1)/lambda
# 
# # z transform the data
# data_long$scr_ztr <- scale(data_long$scr_raw)[,1] #[,1] to get rid of M and SD which is also returned

data_long = data_long %>% 
  mutate(scr_log = log10(1+scr_raw),
         scr_sqr = sqrt(scr_raw)) %>% 
  
  # group_by(stimulus) %>% mutate(scr_shift = scr_raw - min(scr_raw) + 1, 
  #                               lambda = boxcox(scr_shift ~ 1, plotit=F) %>% 
  #                                 bind_cols() %>% filter(y == max(y)) %>% pull(x) %>% mean()) %>% ungroup() %>% 
  # mutate(scr_box_check = (scr_shift ^ lambda - 1) / lambda) %>% 
  group_by(stimulus) %>% mutate(scr_box = boxcoxvec(scr_raw)) %>% ungroup() %>% 
  
  #group_by(id) %>% #this implicitly invokes something similar to a range correction => don't do it? How is it used in the literature?
  mutate(scr_ztr = scale(scr_raw)[,1],
         scr_ztr = scr_ztr - min(scr_ztr)) #make sure that minimum response is 0 (and not negative)

#View(data_long)
#data_long %>% ggplot(aes(x = scr_raw, y = scr_box, color = stimulus)) + geom_point() + myGgTheme
#data_long %>% filter(transformation %>% grepl("box", .)) %>% pivot_wider(names_from=transformation, values_from=scr) %>% filter(scr_box != scr_box_check)

data_long = data_long %>% 
  #select(-scr_shift, -lambda) %>% #remove helping variables
  pivot_longer(starts_with("scr_"), names_to = "transformation", values_to = "scr")
```

```{r range correction}
### Prepare range correction by calculating max SCR of CS and US responses
# Max amplitude CS
# data_long$scr_max_cs <- NA
# for (i in unique(data_long$id)) {
#   data_select <- data_long[which(data_long$id == i & grep("^cs", data_long$stimulus)), ]
#   max_ampl_cs <- max(data_select$scr_raw, na.rm = T)
#   data_long$scr_max_cs[which(data_long$id == i)] <- max_ampl_cs
# }
# 
# # Max amplitude US
# data_long$scr_max_us <- NA
# for (i in unique(data_long$id)) {
#   data_select <- data_long[which(data_long$id == i & grep("ucs", data_long$stimulus)), ]
#   max_ampl_us <- max(data_select$scr_raw, na.rm = T)
#   data_long$scr_max_us[which(data_long$id == i)] <- max_ampl_us
# }
# 
# 
# ### Range correct all transformation types with CS-rc
# data_long$scr_raw_rc_cs <- data_long$scr_raw/data_long$scr_max_cs
# data_long$scr_log_rc_cs <- data_long$scr_log/data_long$scr_max_cs #TODO this also divides by the max raw value but should be max log value?
# data_long$scr_sqr_rc_cs <- data_long$scr_sqr/data_long$scr_max_cs
# data_long$scr_box_rc_cs <- data_long$scr_box/data_long$scr_max_cs
# data_long$scr_ztr_rc_cs <- data_long$scr_ztr/data_long$scr_max_cs
# 
# ### Range correct all transformation types with US-rc
# data_long$scr_raw_rc_us <- data_long$scr_raw/data_long$scr_max_us
# data_long$scr_log_rc_us <- data_long$scr_log/data_long$scr_max_us
# data_long$scr_sqr_rc_us <- data_long$scr_sqr/data_long$scr_max_us
# data_long$scr_box_rc_us <- data_long$scr_box/data_long$scr_max_us
# data_long$scr_ztr_rc_us <- data_long$scr_ztr/data_long$scr_max_us

data_long.max = data_long %>% 
  summarise(scr_max = max(scr, na.rm=T), .by = c(id, stim_cat, transformation)) %>% 
  pivot_wider(names_from = stim_cat, names_prefix = "max_", values_from = scr_max, id_cols = c("id", "transformation"))

data_long.max %>% summarise(across(starts_with("max"), list("min" = min, "max" = max)))
#some participant's max response is negative (probably due to z-transform across all participants, i.e., their max is still below the group average)
# => absolute value of minimum has been "added" to shift z-scored values to a minimum of 0

data_long.max %>% filter(max_cs == 0 | max_ucs == 0)
#subject 446: only zero responses to CSs

data_long.max = data_long.max %>% mutate(across(starts_with("max_"), function(x) {if_else(x == 0, Inf, x)})) #replace 0 with Inf (such that scr / Inf == 0)

data_long = data_long %>% full_join(data_long.max) %>% 
  mutate(scr_rc_cs = scr / max_cs,
         scr_rc_us = scr / max_ucs) %>% 
         #stimulus = if_else(stimulus %>% is.na(), "ucs", stimulus) %>% as_factor()) %>% 
  select(-starts_with("max_")) %>% rename(scr_rc_none = scr) %>% 
  pivot_longer(starts_with("scr_rc_"), names_to = "range_cor", values_to = "scr") %>% 
  mutate(transformation = transformation %>% gsub("scr_", "", .) %>% as_factor(),
         range_cor = range_cor %>% gsub("scr_rc_", "", .) %>% as_factor())

#data_long %>% filter(scr %>% is.nan())
```

```{r cs discrimination}
### Add CS discrimination
# Select data and calculate CS discrimination
# data_cs_dis <- data_long[grep("cspe|csm", data_long$stimulus), ]
# data_cs_dis <- spread(data_cs_dis, stimulus, scr_raw)
# data_cs_dis$csd <- data_cs_dis$cspe - data_cs_dis$csm
# 
# # Reshape data back to wide format
# data_cs_dis <- gather(data_cs_dis, stimulus, scr_raw, csm:csd, factor_key = TRUE)
# 
# # Melt it with US responses in data_long
# data_long <- rbind(data_cs_dis, data_long[grep("ucs", data_long$stimulus) , ])

data_long = data_long %>% filter(stimulus != "ucs") %>% 
  pivot_wider(names_from = stimulus, values_from = "scr") %>% 
  mutate(csd = csp - csm, #"trial"-level cs-difference only works because same amount of cs+ and cs- trials (and trials are counted with cs category)
         stimulus = "csd") %>% rename(scr = csd) %>% #a bit hacky preparation for bind_rows
  select(-csp, -csm) %>% bind_rows(data_long, .)
```

```{r boxcox & csd}
#TODO does it make sense for boxcox to transform first and then calculate difference? Probably not due to different non-linear transformations = non-comparable scales => do boxcox again for raw csd (separate for range_cor, which is a linear transformation)
data_long = data_long %>% filter(transformation=="raw", stimulus=="csd") %>% 
  group_by(range_cor) %>% mutate(scr = boxcoxvec(scr)) %>% ungroup() %>% 
  mutate(transformation="box") %>% 
  bind_rows(data_long %>% filter(transformation!="box" | stimulus!="csd"), .) #%>% full_join(data_long, by = c("id", "trialnr", "stimulus", "stim_cat", "transformation", "range_cor")) %>% filter(scr.x != scr.y) %>% select(stimulus, stim_cat, transformation, range_cor) %>% unique()
```

```{r histograms}
data_plot = data_long %>% 
  #choose order of variables
  mutate(stimulus = stimulus %>% factor(levels=c("csd", "csp", "csm", "ucs")),
         transformation = transformation %>% factor(levels=c("raw", "log", "sqr", "box", "ztr"))) 

data_plot %>% summarise(min = min(scr, na.rm=T), max = max(scr, na.rm=T))
data_plot %>% filter(scr < 0) %>% select(stimulus) %>% unique()

#overkill 1
# print(plot.hist.all <- data_plot %>% 
#   #ggplot(aes(x = scr, fill = stimulus)) + #problem: number of bins not trivial => scale each plot to [0; 1]
#   group_by(stimulus, transformation, range_cor) %>% mutate(scr_scaled = (scr - min(scr)) / (max(scr) - min(scr))) %>% 
#   ggplot(aes(x = scr_scaled, fill = stimulus)) +
#   facet_grid(range_cor + stimulus ~ transformation, labeller = "label_both", scales = "free") + 
#     geom_histogram(color="black") + 
#   myGgTheme + scale_fill_viridis_d(option="C"))
#ggsave("figures/Hist all 1.png", plot=plot.hist.all, scale=3.5, device="png", dpi=300, units="px", width=1920, height = 1080)

#overkill 2
print(plot.hist.all2 <- data_plot %>% 
  #ggplot(aes(x = scr, fill = range_cor)) + #problem: number of bins not trivial => scale each plot to [0; 1]
  group_by(stimulus, transformation, range_cor) %>% mutate(scr_scaled = (scr - min(scr)) / (max(scr) - min(scr))) %>% 
  ggplot(aes(x = scr_scaled, fill = range_cor)) +
  facet_grid(stimulus + range_cor ~ transformation, labeller = "label_both", scales = "free") + 
  geom_histogram(color="black") + 
  myGgTheme + scale_fill_viridis_d())
#ggsave("figures/Hist all 2.png", plot=plot.hist.all2, scale=3.5, device="png", dpi=300, units="px", width=1920, height = 1080)

## CS-Diff plots
#TODO add other information (see chunk below)
print(plot.hist.csd <- data_plot %>% filter(stimulus == "csd") %>% 
  #ggplot(aes(x = scr, fill = transformation)) + #problem: number of bins not trivial => scale each plot to [0; 1]
  group_by(transformation, range_cor) %>% mutate(scr_scaled = (scr - min(scr)) / (max(scr) - min(scr))) %>% 
  ggplot(aes(x = scr_scaled, fill = transformation)) +
  facet_grid(transformation ~ range_cor, labeller = "label_both", scales = "free") + 
  geom_histogram(color="black") + 
  myGgTheme + scale_fill_viridis_d(option="C"))
#ggsave("figures/Hist CS-Diff 1.png", plot=plot.hist.csd, scale=1.75, device="png", dpi=300, units="px", width=1920, height = 1080)

# print(plot.hist.csd2 <- data_plot %>% filter(stimulus == "csd") %>% 
#   #ggplot(aes(x = scr, fill = range_cor)) + #problem: number of bins not trivial => scale each plot to [0; 1]
#   group_by(transformation, range_cor) %>% mutate(scr_scaled = (scr - min(scr)) / (max(scr) - min(scr))) %>% 
#   ggplot(aes(x = scr_scaled, fill = range_cor)) +
#   facet_grid(range_cor ~ transformation, labeller = "label_both", scales = "free") + 
#   geom_histogram(color="black") + 
#   myGgTheme + scale_fill_viridis_d())
#ggsave("figures/Hist CS-Diff 2.png", plot=plot.hist.csd2, scale=1.75, device="png", dpi=300, units="px", width=1920, height = 1080)
```

```{r histograms old}
data_old = data_long %>% filter(transformation=="raw", range_cor=="none") %>% rename(scr_raw = scr) %>% mutate(stimulus = if_else(stimulus=="csp", "cspe", stimulus)) #backwards compatibility

# Create stimulus variable for loop
stim <- c("csd","cspe","csm","ucs")

for (i in unique(stim)) {
  
# Select only stimulus type
#data_hist <- data_long[(which(data_long$stimulus == i)), ]
data_hist <- data_old %>% filter(stimulus == i)

# Select color
if (i == "csd") {
  stim_col <- "darkmagenta"
} else if (i == "cspe") {
  stim_col <- "darkred" 
} else if (i == "csm") {
  stim_col <- "navy"
} else if (i == "ucs") {
  stim_col <- "black"
}

# Select name for x-axis
if (i == "csd") {
  stim_x_axis <- "CS discrimination"
} else if (i == "cspe") {
  stim_x_axis <- "CS+" 
} else if (i == "csm") {
  stim_x_axis <- "CS-"
} else if (i == "ucs") {
  stim_x_axis <- "US"
}


# Calculate means across trials 
data_hist <- aggregate(data_hist[ ,grep("scr", names(data_hist))], by = list(id=data_hist$id, stimulus=data_hist$stimulus), FUN = mean)

# For the plot: calculate mean, mode, median, sd, skewness and kurtosis
mode_hist_raw <- round(Mode(data_hist$scr_raw)[1], 2) 
median_hist_raw <- round(median(data_hist$scr_raw), 2) 
mean_hist_raw <- round(mean(data_hist$scr_raw), 2) 
sd_hist_raw <- round(sd(data_hist$scr_raw), 2)
skew_hist_raw <- round(skewness(data_hist$scr_raw), 2) 
kurt_hist_raw <- round(kurtosis(data_hist$scr_raw), 2)

# Calculate the density to position text
dens <- density(data_hist$scr_raw)
dens_max <- max(dens$y)

############ PLOT

hist_scr_raw <- ggplot(data = data_hist, aes(x = scr_raw)) + 
  geom_histogram(aes(y =..density..), col = "white", fill = stim_col, binwidth = max(data_hist$scr_raw)/25) +
  labs(x=paste0("raw SCR (", stim_x_axis,")"), y="still to fill") +
  
  # Add the density
  geom_density(col = "white", linewidth = 1.6) +
  geom_density(col = stim_col, linewidth = 1) +
  
  # Add a normal distribution
  stat_function(fun = dnorm, args = list(mean = mean(data_hist$scr_raw), sd = sd(data_hist$scr_raw)),
                col = "#06D6A0", linewidth = 1) +

  # Add descriptive values
  geom_vline(aes(xintercept = mean(scr_raw)), col = "#EF476F", linewidth = 0.8) +
  geom_vline(aes(xintercept = Mode(scr_raw)), col = "#FFD166", linewidth = 0.8) +
  geom_vline(aes(xintercept = median(scr_raw)), col = "#909CC2", linewidth = 0.8) +
  
  # Add descriptive values as text
  annotate(geom = "text", x = max(data_hist$scr_raw), y = dens_max*1.3, label = paste( "Mode: ", mode_hist_raw), col = "#FFD166", hjust = 1) +
  annotate(geom = "text", x = max(data_hist$scr_raw), y = dens_max*1.2, label = paste("Median: ", median_hist_raw), col = "#909CC2", hjust = 1) +
  annotate(geom = "text", x = max(data_hist$scr_raw), y = dens_max*1.1, label = paste("Mean: ", mean_hist_raw), col = "#EF476F", hjust = 1) +
  annotate(geom = "text", x = max(data_hist$scr_raw), y = dens_max*0.9, label = paste("SD: ", sd_hist_raw), col = "black", hjust = 1) +
  annotate(geom = "text", x = max(data_hist$scr_raw), y = dens_max*0.8, label = paste("Skewness: ", skew_hist_raw), col = "black", hjust = 1) +
  annotate(geom = "text", x = max(data_hist$scr_raw), y = dens_max*0.7, label = paste("Kurtosis: ", kurt_hist_raw), col = "black", hjust = 1) +
  
  theme(
    axis.title.x = element_text(size = 12, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold"),
    axis.text.y = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(size = 10, face = "bold"),
    strip.background = element_blank(),
    panel.border = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    panel.background = element_blank(),
    axis.line.x = element_line(colour = 'black', size=0.5, linetype='solid'),
    axis.line.y = element_line(colour = 'black', size=0.5, linetype='solid'))

# Name the plot
assign(paste0("hist_scr_raw_",i), hist_scr_raw)

}


### Combine plots
hist_scr_raw_csd + hist_scr_raw_cspe + hist_scr_raw_csm + hist_scr_raw_ucs + plot_layout(ncol = 1)

```

```{r mainEffectraw}

# Factorize stimulus
data_line <- data_old #backwards compatibility

data_line$stimulus <- as.factor(data_line$stimulus)
data_line$stimulus <- factor(data_line$stimulus, levels = c("csd","cspe","csm","ucs"))


# Summarise within stimuli and trials (means and SEMs)
data_line = data_line %>%
  group_by(trialnr, stimulus) %>%
  summarise(scr.mean = mean(scr_raw, na.rm = T), 
            scr.sem = sd(scr_raw, na.rm = T)/sqrt(length(scr_raw)))

# Add confidence intervals to the dataframe (95%)
data_line$lower <- data_line$scr.mean - 1.96*data_line$scr.sem
data_line$upper <- data_line$scr.mean + 1.96*data_line$scr.sem
n_data = length(unique(data_long$id))

#### LINEPLOT
# First part of the plot is acquisition, plotted as points
lineplot_scr_raw <- ggplot(data_line, aes(x=trialnr, y=scr.mean, colour=stimulus, group=stimulus)) +
   geom_point(aes(group=stimulus), size=2) +
  
  # Add lines between points
  geom_line(aes(group=stimulus), size=1.2) +
  # Add CI
  geom_ribbon(aes(ymin=lower, ymax=upper, fill=stimulus, color=NULL), alpha=0.2) +
  
  # Change colors and names of stimuli
  scale_colour_manual(values=c("darkmagenta","darkred","navy","black"), name = "", breaks=c("csd","cspe","csm","ucs"),
                      labels=c("CS discrimination","CS+", "CS-","US")) +
  scale_fill_manual(values=c("darkmagenta","darkred","navy","black"), name = "", breaks=c("csd","cspe","csm","ucs"),
                      labels=c("CS discrimination","CS+", "CS-","US")) +
  scale_x_continuous(breaks = scales::pretty_breaks()) + #integer breaks
  # Title of axes
  xlab("Acquisition trials") +
  ylab("SCR (µS, raw)") +
  # Title of the whole plot can be added here
  ggtitle("") +
  # Add number of participants as text in plot
  annotate("text", x = 8, y = .8, label = paste("n =", n_data), size = 6) +
  # Settings for fonts, ticks, legend and background of the plot
  theme(plot.title = element_text(size=20, face="bold", hjust=0.5),
        axis.text.x = element_text(size=16, face="bold", color="black"),
        axis.text.y = element_text(size=16, face="bold", color="black"), 
        axis.title.x = element_text(size=20, face="bold"),
        axis.title.y = element_text(size=20, face="bold", margin=margin(0,10,0,0)),
        legend.title = element_text(size=16, face="bold"),
        legend.text = element_text(size=16),
        legend.key = element_blank(),
        axis.line.x = element_line(color="black", size = 1),
        axis.line.y = element_line(color="black", size = 1),
        axis.ticks.x=element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

lineplot_scr_raw

```

```{r lineplot-different-transformations-csp}

# Select CS+ responses
# data_CSP <- data_long %>% filter(stimulus=="csp")
# 
# # Exclude max SCR
# #data_CSP <- data_CSP[ ,-grep("_max_", names(data_CSP))]
# 
# # Convert data from wide to long and delete condition column as well as stimulus columns
# #data_CSP <- gather(data_CSP, key = "approach", value = "scr_mean", - c(id, trialnr, stimulus, stim_cat))
# data_CSP = data_CSP %>% mutate(approach = paste(transformation, range_cor, sep="_")) %>% rename(scr_mean = scr_raw)
# data_CSP <- data_CSP[ ,-grep("stimulus", names(data_CSP))]
# 
# # Factorize approach
# data_CSP$approach <- as.factor(data_CSP$approach)
# 
# # Delete box cox, looks strange...
# #data_CSP <- data_CSP[-grep("box", data_CSP$approach), ]

data_CSP <- data_long %>% filter(stimulus=="csp") %>% 
  mutate(approach = paste(transformation, range_cor, sep="_") %>% as_factor()) %>% 
  rename(scr_mean = scr)


# Summarise within transformations (means and SEMs)
rm(data_triallevel)
data_triallevel = data_CSP %>%
  group_by(trialnr, approach) %>%
  summarise(scr.mean = mean(as.numeric(scr_mean), na.rm = T), 
            scr.sem = sd(as.numeric(scr_mean), na.rm = T)/sqrt(length(scr_mean))) #not correct if missing values

# Add confidence intervals to the dataframe (95%)
data_triallevel$lower <- data_triallevel$scr.mean - 1.96*data_triallevel$scr.sem
data_triallevel$upper <- data_triallevel$scr.mean + 1.96*data_triallevel$scr.sem
n_data = length(unique(data_old$id))

#### LINEPLOT: different transformations
gp2 <- ggplot(data_triallevel, aes(x=trialnr, y=scr.mean, colour=approach, group=approach)) +
   geom_point(aes(group=approach), size=2) +
  
  # Add lines between points
  geom_line(aes(group=approach), size=1.2) +
  # Add CI
  geom_ribbon(aes(ymin=lower, ymax=upper, fill=approach, color=NULL), alpha=0.2) +
  
  scale_x_continuous(breaks = scales::pretty_breaks()) + #integer breaks
  # Title of axes
  xlab("Acquisition trials") +
  ylab("SCR") +
  # Title of the whole plot can be added here
  ggtitle("") +
  # Add number of participants as text in plot
  annotate("text", x = 8, y = .8, label = paste("n =", n_data), size = 6) +
  # Settings for fonts, ticks, legend and background of the plot
  theme(plot.title = element_text(size=20, face="bold", hjust=0.5),
        axis.text.x = element_text(size=16, face="bold", color="black"),
        axis.text.y = element_text(size=16, face="bold", color="black"), 
        axis.title.x = element_text(size=20, face="bold"),
        axis.title.y = element_text(size=20, face="bold", margin=margin(0,10,0,0)),
        legend.title = element_text(size=16, face="bold"),
        legend.text = element_text(size=16),
        legend.key = element_blank(),
        axis.line.x = element_line(color="black", size = 1),
        axis.line.y = element_line(color="black", size = 1),
        axis.ticks.x=element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

gp2

```

```{r mainEffectlog}
# tranformation 1 
data_transformed = data_long %>%
  filter(transformation=="log") %>% rename(scr_raw = scr) %>% 
  summarise(scr.mean = mean(scr_raw, na.rm = T), 
            scr.sem = sd(scr_raw, na.rm = T)/sqrt(length(scr_raw)), #not correct if missing values
            .by=c(trialnr, stimulus))

# Add confidence intervals to the dataframe (95%)
data_transformed$lower <- data_transformed$scr.mean - 1.96*data_transformed$scr.sem
data_transformed$upper <- data_transformed$scr.mean + 1.96*data_transformed$scr.sem
n_data = length(unique(data_long$id))

# First part of the plot is acquisition, plotted as points
gp <- ggplot(data_transformed, aes(x=trialnr, y=scr.mean, colour=stimulus, group=stimulus)) +  
  geom_point(aes(group=stimulus), size=2) +
  
  # Add lines between points
  geom_line(aes(group=stimulus), size=1.2) +
  # Add CI
  geom_ribbon(aes(ymin=lower, ymax=upper, fill=stimulus, color=NULL), alpha=0.2) +
  
  # Change colors and names of stimuli
  scale_colour_manual(values=c("blue","red", "darkred","black", "darkgrey", "grey")) +
  #, name = "CS-Type:", breaks=c("CSp","CSm","US"), labels=c("CS+", "CS-","US")
  scale_fill_manual(values=c("blue","red", "darkred","black", "darkgrey", "grey"))+
  scale_x_continuous(breaks = scales::pretty_breaks()) + #integer breaks
  # Title of y-axis
  ylab("SCR (log(1 + µS))") +
  # Title of the whole plot can be added here
  ggtitle("") +
  # Add number of participants as text in plot
  annotate("text", x = 8, y = .8, label = paste("n =", n_data), size = 6) +
  # Settings for fonts, ticks, legend and background of the plot
  theme(plot.title = element_text(size=20, face="bold", hjust=0.5),
        axis.text.x = element_text(size=16, face="bold", color="black"),
        axis.text.y = element_text(size=16, face="bold", color="black"), 
        axis.title.y = element_text(size=20, face="bold", margin=margin(0,10,0,0)),
        legend.title = element_text(size=16, face="bold"),
        legend.text = element_text(size=16),
        legend.key = element_blank(),
        axis.line.x = element_line(color="black", size = 1),
        axis.line.y = element_line(color="black", size = 1),
        axis.ticks.x=element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

gp
```

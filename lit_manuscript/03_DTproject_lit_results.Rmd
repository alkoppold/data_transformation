---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r results}

# This file contains the results: 
# ...


```


```{r results-load-packages-data}

# Load packages
library(tidyverse)
library(scico)
library(forcats)
library(scales)
library(patchwork)
library(dplyr)
library(stringr)
library(forcats)
library(data.table)


# Load data
data_extract = read_rds("data/data_extract.rds") #cf. script "extract_cleanup.R"

```


```{r circle-plot}

# For modern scientific color palettes

#data.frame(colname = data_extract %>% colnames()) %>% mutate(colnum = 1:n()) %>% relocate(colnum)
df <- data_extract %>% select(doi, `HR`:PUPIL_SIZE)
n_total <- df %>% pull(doi) %>% unique() %>% length()

# Step 1: Pivot to long format (no drop_na yet!)
df_long <- df %>%
  pivot_longer(cols = -doi, names_to = "measure", values_to = "transformation")

# Step 2: Calculate proportion of non-NA values BEFORE dropping NAs
measure_percent <- df_long %>%
  group_by(measure) %>%
  summarise(prop = mean(!is.na(transformation))) %>%
  mutate(measure_label = paste0(measure, " (", round(100 * prop, 1), "%)"))

# Step 3: Create label map
label_map <- setNames(measure_percent$measure_label, measure_percent$measure)

### change on label ""rc, sqrt (analysis 1); z (analysis 2)""
#df_long %>% filter(transformation %>% grepl(";", .)) #check columns with ";"
df_long <- df_long %>%
  # Separate on ";" into rows
  separate_rows(transformation, sep = ";") %>%
  # Remove the analysis part in parentheses
  mutate(transformation = str_trim(str_remove(transformation, "\\s*\\(.*?\\)")))

# Step 4: Now drop NAs and apply label map
df_long <- df_long %>%
  drop_na() %>%
  mutate(measure = label_map[measure])

counts <- df_long %>%
  count(measure, transformation, drop = F) #%>%
  #mutate(transformation = ifelse(is.na(transformation), "Missing", transformation))

df_wide <- counts %>%
  pivot_wider(names_from = measure, values_from = n, values_fill = 0) %>%
  mutate(ID = paste0("T", row_number())) %>%
  relocate(ID)

id_labels <- df_wide %>% select(ID, transformation)
id_named_vec <- setNames(id_labels$transformation, id_labels$ID)

d <- df_wide %>%
  pivot_longer(cols = -c(ID, transformation), names_to = "Measure", values_to = "Count") %>%
  filter(Count > 0) %>%
  mutate(Type = ifelse(Count > 1, "more than one study", "one study only"))

d <- setDT(d)
# Step: Create a unique transformation-to-ID mapping
id_order <- d[ , .SD[1], by = transformation][order(transformation)]$ID

# Apply it as the factor level order
d[, ID := factor(ID, levels = id_order)]
#d[, ID := factor(ID, levels = d[, .N, by = ID][order(N)]$ID)]
#d[, Measure := factor(Measure, levels = d[, .N, by = Measure][order(N)]$Measure)]
d[, Measure := factor(Measure, levels = sort(unique(Measure)))]
d[, Measure2 := as.numeric(Measure)]

# Modern, perceptually uniform color palette from scico
#pal1 <- scico(n = length(levels(d$Measure)), palette = "bilbao")
#pal1 <- scico::scico(n = length(levels(d$Measure)), palette = "batlow")
# pal1 <- scico::scico(n = length(levels(d$Measure)), palette = "berlin")
pal1 <- scico(n = length(levels(d$Measure)), palette = "roma")



ggplot(d, aes(x = ID, y = Measure2, color = Measure, shape = Type, group = ID)) +
  geom_line(alpha = 0.5, size = 0.8, color = "grey50") +   # softer connecting lines
  geom_point(size = 5, stroke = 1.2, fill = "white") +      # bigger points, white fill, clear outlines
  geom_hline(yintercept = 1:length(unique(d$Measure)), colour = "grey92", size = 0.3) +
  geom_vline(xintercept = 1:length(unique(d$ID)), colour = "grey92", size = 0.3) +
  geom_rect(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0.6, fill = "white", color = NA) +
  coord_polar() +
  scale_shape_manual(values = c(19, 21)) +
  scale_y_continuous(
    limits = c(0, length(unique(d$Measure)) + 1),
    breaks = 1:length(unique(d$Measure)),
    labels = levels(d$Measure)
  ) +
  scale_color_manual(values = pal1) +
  scale_x_discrete(labels = id_named_vec) +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 13),
    legend.text = element_text(size = 12),
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 13, hjust = 0.5, color = "grey40"),
    panel.border = element_blank()
  ) +
  labs(
    #title = "Transformation Types by Measure and Study",
    #subtitle = paste0("Across ", n_total, " included studies"),
    x = NULL,
    y = NULL,
    shape = "Transformation count",
    color = paste0("Measure used in (% of ", n_total, " studies)")
  )

# Step 1: Calculate total counts per Measure
d[, total_measure_count := sum(Count), by = Measure]

# Step 2: Calculate percentage for each transformation within the measure
d[, pct := 100 * Count / total_measure_count]

# Step 3: Create a label with percentage rounded, e.g. "45%"
d[, pct_label := paste0(round(pct, digits = 1), "%")]

pal1 <- scico(n = length(levels(d$Measure)), palette = "lipari")
pal1 = rev(pal1)


# Step 4: Add geom_text to the plot, adjust position with nudge_x or nudge_y
ggplot(d, aes(x = ID, y = Measure2, color = Measure, shape = Type, group = ID)) +
  geom_line(alpha = 0.5, size = 0.8, color = "grey50") +
  geom_point(aes(size = pct), stroke = 1.2, fill = "white") +  # SIZE mapped to pct
  geom_hline(yintercept = 1:length(unique(d$Measure)), colour = "grey92", size = 0.3) +
  geom_vline(xintercept = 1:length(unique(d$ID)), colour = "grey92", size = 0.3) +
  geom_rect(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0.6, fill = "white", color = NA) +
  coord_polar() +
  scale_shape_manual(values = c(19, 21)) +
  scale_y_continuous(
    limits = c(0, length(unique(d$Measure)) + 1),
    breaks = 1:length(unique(d$Measure)),
    labels = levels(d$Measure)
  ) +
  scale_color_manual(values = pal1) +
  scale_size(range = c(2, 10), name = "Percentage within measure") +  # Dot size scale
  scale_x_discrete(labels = id_named_vec) +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 13),
    legend.text = element_text(size = 12),
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 13, hjust = 0.5, color = "grey40"),
    panel.border = element_blank()
  ) +
  labs(
    x = NULL,
    y = NULL,
    shape = "Transformation count",
    color = paste0("Measure used in (% of ", n_total, " studies)")
  )


```


```{r assumptions-prepare-data}

# Extract and rename relevant columns
#data.frame(colname = data_extract %>% colnames()) %>% mutate(colnum = 1:n()) %>% relocate(colnum)
df_check = data_extract %>% select(normality:multicollinearity_how, statistical_test)

names(df_check) <- c(
  "normal_distribution",
  "normal_how",
  "normal_before_after",
  "homoscedasticity",
  "homoscedasticity_how",
  #"sphericity", #sphericity old, which got deselected
  "sphericity_how", 
  "independence of residuals",
  "independence_how",
  "linearity",
  "linearity_how",
  "multicollinearity",
  "multicollinearity_how",
  "statistical_test"
)

```


```{r results-assumptions-overview}

# Select the data
data_assump <- data_extract %>% select(normality, homoscedasticity, sphericity, independence, linearity, multicollinearity)
names(data_assump) <- c("Normality","Homoscedasticity","Sphericity","Independence","Linearity","Multicollinearity")

# Reshape it from wide to long
data_assump <- data_assump %>%
  mutate(Sphericity = case_when(Sphericity == "not reported" ~ "not reported",
                                Sphericity %>% is.na() ~ NA, #TODO should this be mapped to "not reported"?
                                T ~ "yes")) %>% 
  pivot_longer(cols = everything(), names_to = "Assumption", values_to = "Checked") %>%
  count(Assumption, Checked) %>%
  group_by(Assumption) %>%
  mutate(
    percent = n / sum(n),
    label = scales::percent(percent)
  )

# Factorize the assumptions and checked variable and reorder the levels (for a more intuitive order)
data_assump$Assumption <- as.factor(data_assump$Assumption)
data_assump$Assumption <- factor(data_assump$Assumption,
                                    levels = c("Normality","Homoscedasticity","Sphericity",
                                               "Independence","Linearity","Multicollinearity"))
data_assump$Checked <- as.factor(data_assump$Checked)
data_assump$Checked <- factor(data_assump$Checked,
                                    levels = c("not reported","not specified","yes",
                                               "dependent variable"))

ggplot(data_assump, aes(x = factor(Assumption), y = n, fill = Checked)) +
  geom_bar(stat = "identity") +
  scale_fill_viridis_d(option = "D", alpha = 0.95) +
  geom_text(aes(label = label), 
            position = position_stack(vjust = 0.5), 
            color = "white", size = 4, fontface = "bold") +
  labs(y = "n studies") +
  lit_theme +
  theme(axis.title.y = element_blank(),
        legend.position = "top")+
  coord_flip() 
  

```


```{r assumptions-pie-charts}

# -----------------------------
# Prepare data for pie charts
# -----------------------------
#data.frame(colname = df_check %>% colnames()) %>% mutate(colnum = 1:n()) %>% relocate(colnum)
df_cake <- df_check %>% select(normal_distribution, homoscedasticity, sphericity_how, linearity, multicollinearity)

# Customize normality column: if normality is not "not reported" -> yes
df_cake$normal_distribution[df_cake$normal_distribution != "not reported"] <- "yes"

# Set names for plot titles
names(df_cake) <- c("Normality","Homoscedasticity","Sphericity","Linearity","Multicollinearity")

# Prepare the plot data frame
df_long <- df_cake %>%
  pivot_longer(cols = everything(), names_to = "assumption", values_to = "status") %>%
  group_by(assumption, status) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(assumption) %>%
  mutate(
    percent = count / sum(count),
    label = paste0(round(percent * 100, digits = 1), "% (", count, ")"),
    ymax = cumsum(percent),
    ymin = lag(ymax, default = 0),
    label_pos = (ymin + ymax) / 2
  )

# Function to create pie chart with outer label positions
create_pie <- function(var_name) {
  df_sub <- df_long %>% filter(assumption == var_name)
  
  ggplot(df_sub, aes(ymax = ymax, ymin = ymin, xmax = 1, xmin = 0, fill = status)) +
    geom_rect(color = "white") +
    geom_text(
      aes(x = 1.2, y = label_pos, label = label),
      size = 4, fontface = "bold", color = "black"
    ) +
    coord_polar(theta = "y") +
    xlim(c(-0.5, 1.5)) +
    scale_fill_scico_d(palette = "vanimo", direction = -1) +
    theme_void(base_family = "Calibri") +
    theme(
      legend.position = "right",
      plot.title = element_text(face = "bold", hjust = 0.5, size = 13),
      legend.title = element_blank()
    ) +
    labs(fill = "status",
      title = var_name
    )
}

# Collect pies
pies <- unique(df_long$assumption) %>% map(create_pie)


```

```{r assumptions-homosc-linearity-multicoll}

# Create a plot for homoscedasticity, linearity and multicollinearity

# Turn of the legends for pie 1 and 2
pies[[1]] <- pies[[1]] + theme(legend.position = "none")
pies[[2]] <- pies[[2]] + theme(legend.position = "none")

# Patchwork the pies
coll_pies <- pies[[1]] + pies[[2]] + pies[[3]] 

coll_pies

```


```{r assumptions-normal-distributions}

# -----------------------------
# Create normal_distribution bar plot with percentages
# -----------------------------
plot_normal_bar <- df_check %>%
  filter(!is.na(normal_distribution)) %>%
  count(normal_distribution) %>%
  mutate(percent = n / sum(n)) %>%
  ggplot(aes(x = fct_reorder(normal_distribution, n), y = n, fill = normal_distribution)) +
  scale_y_continuous(breaks = seq(0, 600, by = 100), limits = c(0, 600),
                     expand = expansion(mult = c(0, 0.1))) +
  geom_col(width = 0.7) +
  geom_text(aes(label = paste0(" (", round(percent * 100, digits = 1), "%)")), 
            hjust = -0.1, size = 3, fontface = "bold") +
  scale_fill_scico_d(palette = "hawaii", direction = -1) +
  coord_flip() +
  theme_minimal(base_family = "Calibri") +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = 13, face = "bold"),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),  
    axis.line = element_line(color = "black"),  
    axis.ticks = element_line(color = "black"),  
  ) +
  labs(
    title = "",
    y = "Number of studies"
  )

# -----------------------------
# Combine pie chart with bar plot
# -----------------------------

# Delete the title of the pie chart
pies[[4]] <- pies[[4]] + theme(plot.title = element_blank())

# Combine the pie chart with the bar chart
normality_plot <- pies[[4]] + plot_normal_bar +
  plot_annotation(
    title = "Was the normal distribution tested and how?",
    tag_levels = "A",
    theme = theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))
  )

# Display
normality_plot


```


```{r assumptions-sphericity}

# Load required libraries
library(tidyverse)
library(scales)
library(glue)
library(scico)
library(forcats)

### Prepare the data
# Filter and select relevant variables
#data.frame(colname = data_extract %>% colnames()) %>% mutate(colnum = 1:n()) %>% relocate(colnum)
df_rmanova_spher <- data_extract %>%
  filter(statistical_test_details == "rmANOVA") %>% #TODO number of within factor levels
  select(sphericity) %>%
  drop_na(sphericity)

# Total articles with rmANOVA
n_articles_rmANOVA <- nrow(df_rmanova_spher)

# Split cell with several entries divided by "," and remove NAs
vec_spher <- unlist(strsplit(df_rmanova_spher$sphericity, split = ",\\s*"))
vec_spher <- vec_spher[!is.na(vec_spher)]

# Delete spaces in front of 2 Greenhouse-Geissers
vec_spher <- gsub(" Greenhouse–Geisser correction", "Greenhouse–Geisser correction", vec_spher)


# -------------------------------
# BAR PLOT: sphericity_how
# -------------------------------

df_bar_spher <- tibble(response = vec_spher) %>%
  count(response) %>%
  mutate(
    percent = n / n_articles_rmANOVA,
    response = fct_reorder(response, n)
  )

plot_sphericity_bar <- ggplot(df_bar_spher, aes(x = response, y = n, fill = response)) +
  geom_col(width = 0.7) +
  geom_text(
    aes(label = paste0(" (", round(percent * 100, digits = 1), "%)")),
    hjust = -0.1, size = 3, fontface = "bold"
  ) +
  scale_y_continuous(
    breaks = seq(0, max(df_bar_spher$n) + 50, by = 20),
    limits = c(0, max(df_bar_spher$n) + 50),
    expand = expansion(mult = c(0, 0.1))
  ) +
  scale_fill_scico_d(palette = "hawaii", direction = -1, guide = "none") +
  coord_flip() +
  theme_minimal(base_family = "Calibri") +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = 13, face = "bold"),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  ) +
  labs(
    title = "How Was Sphericity Checked?",
    y = "Number of studies"
  )

# -----------------------------
# Combine pie chart with bar plot
# -----------------------------

# Delete the title of the pie chart
pies[[5]] <- pies[[5]] + theme(plot.title = element_blank())

# Combine the pie chart with the bar chart
sphericity_plot <- pies[[5]] + plot_sphericity_bar +
  plot_annotation(
    title = "Was the sphericity checked and how?",
    tag_levels = "A",
    theme = theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))
  )

# Display
sphericity_plot


```


```{r stats-models}

library(ggrepel)

### Create a pie chart for the statistical model

# Select data
#data.frame(colname = df_check %>% colnames()) %>% mutate(colnum = 1:n()) %>% select(colnum, everything())
df_cake_stats <- df_check %>% select(statistical_test)

# Split cell with several entries divided by "," and remove NAs
vec_stats <- unlist(strsplit(as.vector(df_cake_stats[[1]]), split = ",\\s*"))
vec_stats <- vec_stats[!is.na(vec_stats)]

### Too many different entries, let's reduce them and name them "other"
# Count occurrences
counts_vec_stats <- table(vec_stats)

# Identify entries with counts < 5
to_other <- names(counts_vec_stats[counts_vec_stats < 5])

# Replace those entries with "other"
vec_stats <- ifelse(vec_stats %in% to_other, "other", vec_stats)

# Convert to data frame and process
df_long_stats <- tibble(Model = vec_stats) %>%
  count(Model) %>%
  mutate(
    percent = n / sum(n),
    label = paste0(round(percent * 100, 1), "% (", n, ")"),
    ymax = cumsum(percent),
    ymin = lag(ymax, default = 0),
    label_pos = (ymin + ymax) / 2
  )



# Prepare radial positioning of the labels
df_long_stats <- df_long_stats %>%
  mutate(
    angle = 90 - 360 * (label_pos),  # for label rotation
    hjust = ifelse(angle < -90, 1, 0),  # flip if upside-down
    angle = ifelse(angle < -90, angle + 180, angle)  # rotate text properly
  )

# Plot it
cake_plot_stats <- ggplot(df_long_stats, aes(ymax = ymax, ymin = ymin, xmax = 1, xmin = 0, fill = Model)) +
  geom_rect(color = "white") +
  geom_text(
    aes(x = 1.05, y = label_pos, label = label, angle = angle, hjust = hjust),
    size = 3.8,
    fontface = "bold",
    color = "black"
  ) +
  coord_polar(theta = "y") +
  xlim(c(0, 1.5)) +
  scale_fill_scico_d(palette = "hawaii", direction = -1) +
  theme_void(base_family = "Calibri") +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", hjust = 0.5, size = 13),
    legend.title = element_blank()
  ) +
  labs(fill = "Model", title = "")

cake_plot_stats



# Or a bar plot?
bar_plot_stats <- ggplot(df_long_stats, aes(x = reorder(Model, n), y = n, fill = Model)) +
  geom_col() +
  geom_text(aes(label = label), hjust = -0.1) +
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +  
  theme_minimal(base_family = "Calibri") +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = 13, face = "bold"),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),  
    axis.line = element_line(color = "black"),  
    axis.ticks = element_line(color = "black")
  ) + labs(
    title = "",
    y = "Number of studies"
  )

bar_plot_stats



```


### c. Transformation Practices
specification of data transformation method, rationale, was the transformation applied on trial or average level
the different data transformations (how many studies use raw data?)
```{r results-transformations}


### SCR
data_trans_scr <- na.omit(data_extract[ , c(40, 48, 45)])
names(data_trans_scr) <- c("scr_transf", "transf_level", "rationale_di")

# Extract SCR-relevant info from multi-measure cells and uniformly code
data_trans_scr <- data_trans_scr %>%
  mutate(transf_level = case_when(
    grepl("SCR: not reported", transf_level) ~ "not reported",
    grepl("SCR: trial-level", transf_level) ~ "trial-level",
    grepl("across trials", transf_level) ~ "trial-level",
    grepl("assume on trial-level", transf_level) ~ "trial-level",
    TRUE ~ transf_level  # keep original
  ))

# Convert to long format
data_trans_scr <- data_trans_scr %>%
  make_long(scr_transf, transf_level, rationale_di)

# data_trans_scr$node <- factor(data_trans_scr$node, levels = sort(unique(data_trans_scr$node)))


# Plot the Sankey diagram
ggplot(data_trans_scr, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("scr_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("SCR: Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(), 
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_scr_sankey.png", width = 14, height = 8, dpi = 300)


### SCL
data_trans_scl <- na.omit(data_extract[ ,c(41, 48, 45)])
names(data_trans_scl) <- c("scl_transf", "transf_level", "rationale_di")

# Convert to long format
data_trans_scl <- data_trans_scl %>%
  make_long(scl_transf, transf_level, rationale_di)

# Plot the Sankey diagram
ggplot(data_trans_scl, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("scl_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("SCL: Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_scl_sankey.png", width = 14, height = 8, dpi = 300)


### EMG Startle
data_trans_emg_startle <- na.omit(data_extract[ ,c(39, 48, 45)])
names(data_trans_emg_startle) <- c("emg_startle_transf", "transf_level", "rationale_di")

# Extract SCR-relevant info from multi-measure cells and uniformly code
data_trans_emg_startle <- data_trans_emg_startle %>%
  mutate(transf_level = case_when(
    grepl("Startle: not reported", transf_level) ~ "not reported",
    grepl("Startle: trial-level", transf_level) ~ "trial-level",
    grepl("FPS: trial-level", transf_level) ~ "trial-level",
    grepl("EMG: average-level", transf_level) ~ "average-level",
    grepl("across trials", transf_level) ~ "trial-level",
    grepl("SCR: trial-level", transf_level) ~ "not reported",
    TRUE ~ transf_level  # keep original
  ))

# Convert to long format
data_trans_emg_startle <- data_trans_emg_startle %>%
  make_long(emg_startle_transf, transf_level, rationale_di)

# Plot the Sankey diagram
ggplot(data_trans_emg_startle, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("emg_startle_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("EMG Startle: Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_emgstartle_sankey.png", width = 14, height = 8, dpi = 300)


### EMG orbicularis oculi
data_trans_emg_orbic <- na.omit(data_extract[ ,c(38, 48, 45)])
names(data_trans_emg_orbic) <- c("emg_orbic_transf", "transf_level", "rationale_di")

# Convert to long format
data_trans_emg_orbic <- data_trans_emg_orbic %>%
  make_long(emg_orbic_transf, transf_level, rationale_di)

# Plot the Sankey diagram
ggplot(data_trans_emg_orbic, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("emg_orbic_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("EMG Orbicularis Oculi: Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_emgorbic_sankey.png", width = 14, height = 8, dpi = 300)


### HR
data_trans_hr <- na.omit(data_extract[ ,c(36, 48, 45)])
names(data_trans_hr) <- c("hr_transf", "transf_level", "rationale_di")

# Convert to long format
data_trans_hr <- data_trans_hr %>%
  make_long(hr_transf, transf_level, rationale_di)

# Plot the Sankey diagram
ggplot(data_trans_hr, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("hr_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("HR (bpm): Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_hr_sankey.png", width = 14, height = 8, dpi = 300)


### HRV
data_trans_hrv <- na.omit(data_extract[ ,c(37, 48, 45)])
names(data_trans_hrv) <- c("hrv_transf", "transf_level", "rationale_di")

# Convert to long format
data_trans_hrv <- data_trans_hrv %>%
  make_long(hrv_transf, transf_level, rationale_di)

# Plot the Sankey diagram
ggplot(data_trans_hrv, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("hrv_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("HRV: Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_hrv_sankey.png", width = 14, height = 8, dpi = 300)


### Eye tracking
data_trans_eyetrack <- na.omit(data_extract[ ,c(42, 48, 45)])
names(data_trans_eyetrack) <- c("eyetrack_transf", "transf_level", "rationale_di")

# Convert to long format
data_trans_eyetrack <- data_trans_eyetrack %>%
  make_long(eyetrack_transf, transf_level, rationale_di)

# Plot the Sankey diagram
ggplot(data_trans_eyetrack, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("eyetrack_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("Eye tracking: Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_eyetrack_sankey.png", width = 14, height = 8, dpi = 300)


### Pupil size
data_trans_pupil <- na.omit(data_extract[ ,c(43, 48, 45)])
names(data_trans_pupil) <- c("pupil_transf", "transf_level", "rationale_di")

# Convert to long format
data_trans_pupil <- data_trans_pupil %>%
  make_long(pupil_transf, transf_level, rationale_di)

# Plot the Sankey diagram
ggplot(data_trans_pupil, aes(x = x, 
                    next_x = next_x, 
                    node = node, 
                    next_node = next_node, 
                    label = factor(node))) +
  geom_sankey(flow.alpha = 0.7, aes(fill = factor(node))) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("pupil_transf", "transf_level", "rationale_di"),
                   labels = c("Transformation", "Level", "Rationale")) +
  ggtitle("Pupil size: Data Transformation Methods, Application Level and Reporting Rationale") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
        plot.title = element_text(size=18, face="bold"))

ggsave("datatransf_rationale_pupil_sankey.png", width = 14, height = 8, dpi = 300)

```


### d. Outlier Practices
outlier removal reported?, outlier criterion, outlier refer to
z.B. Barplots of how often outlier removal is reported
Compare frequencies of different criteria (e.g., +/-2SD vs. +/-3SD)

```{r results-outlier}

### Outlier removal methods
#data.frame(colname = data_extract %>% colnames()) %>% mutate(colnum = 1:n()) %>% relocate(colnum)
data_outlier <- data_extract %>%
  select(outlier:outlier_how) %>%
   rename_with(~ c("outlier_reported", "outlier_scope", "outlier_criterion"), everything()) %>%
    filter(!if_all(everything(), ~ is.na(.) | . == ""))

# previous code scrap: check why this row was changed
# mutate(
#     outlier_scope = ifelse(row_number() == 34, "not reported", outlier_scope))
  
# Group outlier categories 
data_outlier_grouped <- data_outlier %>%
  mutate(
    outlier_criterion_group = case_when(
      str_detect(outlier_criterion, regex("\\bSD\\b", ignore_case = TRUE)) ~ "SD-based threshold (e.g., ± 3 SD)",
      str_detect(outlier_criterion, regex("\\bZ\\b")) ~ "Z-based threshold (e.g., Z > 3)",
      str_detect(outlier_criterion, regex("IQR", ignore_case = TRUE)) ~ "IQR-based threshold (e.g., > Q3 + 1.5*IQR)",
      str_detect(outlier_criterion, regex("Mahalanobis|Grubbs|correlation", ignore_case = TRUE)) ~ "statistical tests (e.g., Mahalanobis distance, Smirmov–Grubbs)",
      str_detect(outlier_criterion, "visual inspection") ~ "manual visual inspection",
      str_detect(outlier_criterion, regex("not reported", ignore_case = TRUE)) ~ "not reported",
      is.na(outlier_criterion) ~ NA_character_,
      TRUE ~ "other"
    )
  )

# Convert to long format
data_outlier_grouped_long <- data_outlier_grouped%>%
  make_long(outlier_reported, outlier_scope, outlier_criterion_group) %>%
  filter(!if_all(c(node), is.na))

### Outlier removal: Sankey Plot 
ggplot(data_outlier_grouped_long, aes(x = x, 
               next_x = next_x, 
               node = node, 
               next_node = next_node,
               fill = factor(node),
               label = node)) +
  geom_sankey(flow.alpha = 0.5, node.color = 1) +
  geom_sankey_label(size = 4, color = 1, fill = "white") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  scale_x_discrete(breaks = c("outlier_reported", "outlier_scope", "outlier_criterion_group"),
                   labels = c("Outlier removal reported?", "Scope", "Criterion")) +
  ggtitle("Outlier Removal: Reporting Practices, Scope and Outlier Criterion") +
  lit_theme + 
  theme(axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(), 
        plot.title = element_text(size=18, face="bold"))

ggsave("outlier_removal_sankey.png", width = 14, height = 8, dpi = 300)


# Group the outlier criterion thresholds by type (SD-, IQR- or Z-based)
data_outlier_grouped_plots <- data_outlier_grouped %>%
  mutate(
    cutoff_value = case_when(
      outlier_criterion_group == "IQR-based threshold (e.g., > Q3 + 1.5*IQR)" ~ str_extract(outlier_criterion, "\\d+(\\.\\d+)?(?=\\*IQR)"),
      outlier_criterion_group %in% c("SD-based threshold (e.g., ± 3 SD)", "Z-based threshold (e.g., Z > 3)") ~ str_extract(outlier_criterion, "\\d+(\\.\\d+)?"),
      TRUE ~ NA_character_
    ),
    cutoff_value = as.numeric(cutoff_value)
  ) %>%
  filter(!is.na(cutoff_value))  # Keep only valid cutoffs


### Barplot of individual outlier criterion thresholds
ggplot(data_outlier_grouped_plots, aes(x = factor(cutoff_value), fill = outlier_criterion_group)) +
  geom_bar(position = "stack") +
  labs(
    title = "Most Common Outlier Thresholds by Criterion Type",
    x = "Threshold Value", y = "Count", fill = "Criterion Group") +
  scale_fill_viridis_d(option = "A", alpha = 0.95) +
  lit_theme + 
  theme(axis.title.x = element_blank(), 
        plot.title = element_text(size=18, face="bold"), 
        legend.position = "right",
        legend.text = element_text(size = 12),         
        legend.title = element_text(size = 14, face = "bold"))
  
ggsave("outlier_removal_thresholds_barplot.png", width = 14, height = 8, dpi = 300)

```



```{r results-descriptives}
#TODO: check everything! many column were not approved in quality control
#e.g., n_with_exclusions are now n_before_exclusion vs. n_after_exclusions (+ multiple entries)
#data_extract %>% select(starts_with("n_"))

# Define a theme for pretty plots
lit_theme = theme(
  text = element_text(size = 10),
  axis.title.x = element_text(size = 16, face = "bold"),
  axis.title.y = element_text(size = 16, face = "bold"),
  axis.text.y = element_text(size = 12, face = "bold"),
  axis.text.x = element_text(size = 14, face = "bold"),
  axis.ticks.x = element_blank(),
  legend.position = "none",
  panel.border = element_blank(),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  panel.background = element_blank(),
  axis.line.x = element_line(colour = 'black', size=0.5, linetype='solid'),
  axis.line.y = element_line(colour = 'black', size=0.5, linetype='solid'))


# Number of all participants

violin_n <- ggplot(aes(x = 1, y = n_with_exclusions), data = data_extract) +
  geom_violin(width = 0.5, scale = "width", fill = "#F7AEF8", alpha = 0.5) +  # Color the whole violin
  geom_boxplot(width = 0.1, color = "grey40", alpha = 0.2) +  # Transparent boxplot
  geom_jitter(width = 0.1, size = 2, alpha = 0.7, color = "#F7AEF8") +  # Individual points
  xlab("") +
  ylab("Number of participants") +
  scale_y_continuous(breaks = seq(0, 150, by = 25),
                     labels =  seq(0, 150, by = 25), limits = c(0, 150)) +
  lit_theme +
  theme(axis.text.x = element_blank(),
        axis.line.x = element_blank())



# Number of females

violin_female <- ggplot(aes(x = 1, y = n_female_total), data = data_extract) +
  geom_violin(width = 0.5, scale = "width", fill = "#B388EB", alpha = 0.5) +  
  geom_boxplot(width = 0.1, color = "grey40", alpha = 0.2) +  
  geom_jitter(width = 0.1, size = 2, alpha = 0.7, color = "#B388EB") +  
  xlab("") +
  ylab("Number of female participants") +
  scale_y_continuous(breaks = seq(0, 100, by = 25),
                     labels = seq(0, 100, by = 25), limits = c(0, 100)) +
  lit_theme +
  theme(axis.text.x = element_blank(),
        axis.line.x = element_blank())


# Mean age distribution

violin_age_mean <- ggplot(aes(x = 1, y = age_mean_total), data = data_extract) +
  geom_violin(width = 0.5, scale = "width", fill = "#8093F1", alpha = 0.5) +  
  geom_boxplot(width = 0.1, color = "grey40", alpha = 0.2) +  
  geom_jitter(width = 0.1, size = 2, alpha = 0.7, color = "#8093F1") +  
  xlab("") +
  ylab("Mean age of participants") +
  scale_y_continuous(breaks = seq(0, 50, by = 10),
                     labels = seq(0, 50, by = 10), limits = c(0, 50)) +
  lit_theme +
  theme(axis.text.x = element_blank(),
        axis.line.x = element_blank())


# SD Age distribution

violin_age_sd <- ggplot(aes(x = 1, y = age_sd_total), data = data_extract) +
  geom_violin(width = 0.5, scale = "width", fill = "#72DDF7", alpha = 0.5) +  
  geom_boxplot(width = 0.1, color = "grey40", alpha = 0.2) +  
  geom_jitter(width = 0.1, size = 2, alpha = 0.7, color = "#72DDF7") +  
  xlab("") +
  ylab("SD age of participants") +
  scale_y_continuous(breaks = seq(0, 12, by = 3),
                     labels = seq(0, 12, by = 3), limits = c(0, 12)) +
  lit_theme +
  theme(axis.text.x = element_blank(),
        axis.line.x = element_blank())


### Combine the plots using patchwork
combined_violin_descript_plot <- violin_n + violin_female + violin_age_mean + violin_age_sd +
  plot_layout(ncol = 4)

# Display the combined plot
combined_violin_descript_plot



```


